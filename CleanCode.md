# Clean Code

重要章节：第七章：错误处理，第九章：单元测试，第十一章：并发编程和第十四章：逐步改进。

# 1. 错误处理

## 1.1 先写Try-Catch_Finally语句

异常的妙处之一是，它们在程序中定义了一个范围。执行try-catch-finally语句中try部分的代码时，你是在表明可随时取消执行，并在catch语句中接续。
在某些意义上，try代码块就像是事务。catch代码块将程序维持在一种持续状态，无论try代码块中发生了什么均如此。所以在编写可能抛出异常的代码时，最好先写出try-catch-finally语句。

## 1.2 使用不可控异常

可控制异常的代价就是违反开放/闭合原则。如果你在方法中抛出可控异常，而catch语句在三个层级之上，你就得在catch语句和抛出异常处之间的每个方法签名中声明该异常。这意味着对软件中底层级的修改，都将波及较高层级的签名。修改好的模块必须重新构建、发布，即使它们自身所关注的任何东西都没改动过。

## 1.3 给出异常发生的环境说明

你抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所。应创建信息充分的错误信息，并和异常一起传递出去。在消息中，包括失败的操作和失败类型。如果你的应用程序有日志系统，传递足够的信息给catch块，并记录下来。

## 1.4 别返回null值

```java
List<Employee> employees = getEmployees();
if (employees != null) {
	for(Employee e : employees) {
		totalPay += e.getPay();
	}
}
```
修改getEmployees()方法
```java
public List<Employee> getEmployees() {
	if( ... ) 
		return Collections.emptyList();
}
```
## 1.5 别传递null值

# 2. 单元测试

## 2.1 TDD三定律

1. 在编写不能通过的单元测试前，不可编写生产代码
2. 只可编写刚好无法通过的单元测试，不能编译也算不通过
3. 只可编写刚好足以通过当前失败测试的生产代码

## 2.2 整洁的测试

构造-操作-检验（BUILD-OPERATE-CHECK）模式

- 第一个环节构造测试数据
- 第二个环节操作测试数据
- 第三个部分检验操作是否得到期望的结果

# 3. 并发编程

## 3.1 为什么要并发

**并发是一种解耦策略。它帮助我们把做什么（目的）和何时（时机）做分解开。**
解耦的目的与时机能够明显地改进应用程序的吞吐量和结构。

## 3.2 并发防御原则

### 3.2.1 单一权责原则

单一权责原则（SRP）认为，方法/类/组件应当只有一个修改的理由。并发设计自身足够复杂到成为修改的理由，所以也该从其他代码中分离出来。

- 并发相关代码有自己的开发、修改和调优生命周期
- 开发相关代码有自己要对付的挑战，和非并发相关代码不同，而且往往更为困难
- 即便没有周边应用程序增加的负担，写得不好的并发代码可能出错方式数量也已经足具挑战性

### 3.2.2 推论：限制数据作用域

采用synchronized在代码中保护一块使用共享对象的临界区（critical section）。限制临界区的数量很重要。更新共享数据的地方越多，就越可能：

- 你会忘记保护一个或多个临界区--破坏了修改共享数据的代码
- 得多花力气保证一切都受到有效防护
- 很难找到错误源，也很难判断错误源
- 
建议：谨记数据封装；严格限制对可能被共享的数据的访问

### 3.2.3 推论：使用数据副本

一开始就避免共享数据。在某些情况下，有可能复制对象并以只读方式对待。在另外的情况下，有可能复制对象，从多个线程收集所有副本的结果，并在单个线程中合并这些结果。

### 3.2.4 推论：线程应尽可能地独立

让每个线程在自己的世界中存在，不与其他线程共享数据
建议：尝试将数据分解到可被独立线程操作的独立子集

## 3.3 了解执行模型

- 限定资源：并发环境中有着固定尺寸或数量的资源。例如数据库连接和固定尺寸读/写缓存等
- 互斥：每一时刻仅有一个线程能访问共享数据或共享资源
- 线程饥饿：一个或一组线程在很长时间内或永久被禁止。例如，总是让执行得快的线程先运行，假如执行得快的线程没完没了，则执行时间长的线程就会“挨饿”
- 死锁：两个或多个线程互相等待执行结束。每个线程都拥有其他线程需要的资源，得不到其他线程拥有的资源，就无法终止
- 活锁：执行次序一致的线程，每个都想要起步，但发现其他线程已经“在路上”。由于竞步的原因，线程会持续尝试起步，但在很长时间内却无法如愿，甚至永远无法启动。

## 3.4 警惕同步方法之间的依赖

避免使用一个共享对象的多个方法

## 3.5 尽可能减小同步区域

## 3.6 测试线程代码

- 将伪失败看作可能的线程问题
- 先使非线程代码可工作
- 编写可插拔的线程代码
- 编写可调整的线程代码
- 运行多于处理器数量的线程
- 在不同平台上运行
- 调整代码并强迫错误发生

