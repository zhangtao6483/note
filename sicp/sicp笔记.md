# SICP笔记

## 第一章 概念

### 1.1 代换模型
**组合式和复合过程确定的计算过程是（代换模型）：**
1. 求出各参数表达式（子表达式）的值
2. 找到要调用的过程的定义（根据第一个子表达式的求值结果）
3. 用求出的实际参数代换过程体里的形式参数
4. 求值过程体

### 1.2 计算进程

![enter image description here](https://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-7.gif)

-  先展开后收缩：展开中积累一些计算，收缩是完成这些计算
- 解释器要维护待执行计算的轨迹，轨迹长度与后续计算的次数成正比
- 积累长度为线性的，计算序列的长度也为线性，称为**线性递归进程**

![enter image description here](https://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-10.gif)

- 没有展开/收缩，直接计算
- 计算轨迹中的信息量为常量，只要维护几个变量的当前值
- 计算序列的长度为线性的具有这种性态的计算进程称为**线性迭代进程**

尾递归形式和尾递归优化
- 一个递归定义的过程称为是尾递归的，如果其中对本过程的递归调用都是过程执行的最后一个表达式
- 虽然是递归定义过程，计算所需的存储却不随递归深度增加。尾递归技术就是重复使用原过程在执行栈里的存储，不另行分配

![enter image description here](https://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-13.gif)

**树形递归**

**换硬币**
人民币的硬币有1元，5角，1角，5分，2分和1分
*问题*：给了一定的人民币，问有多少种不同方式将它换成硬币？
这个问题用递归方式解决比较简单和自然
首先要分析问题，规划出一种对问题的递归观点（算法）

  例如：确定一种硬币排列，币值 a 换为硬币的不同方式等于：
    -  将 a 换为不用第一种硬币的方式，加上
    - 用一个第一种硬币（设币值为 b）后将 a-b 换成各种硬币的方式

这里把用 k 种硬币得到币值 a 归结为两个更简单的情况
- 用 k - 1 种硬币得到 a （减少一种硬币）
- k 种硬币得到较少的币值（前面说的 a-b，减少了币值）

换硬币的几种基本情况：
- a = 0，计 1 种方式
- a < 0，计 0 种方式，因为不合法
- 货币种类 n = 0 但 a 不是 0，计 0 种方式，因为已无货币可用

**递归的观点（递归的分析）**
设法把解决原问题归结为在一定条件下解决一个/几个相对更简单的同类问题（或许还有另外的可以直接解决的问题）

###1.3 高阶函数（Higher-order function）

[高阶函数](https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0)是**至少满足**下列一个条件的函数：
- 接受一个或多个函数作为输入
- 输出一个***函数***

**高阶过程：**以过程作为参数或返回值，操作过程的过程

**lambda 表达式**是把一段计算参数化，抽象为一个（匿名）过程

直接使用 lambda 表达式，主要作用是
- 不引入过程名，简单（如果只用一次）
-  直接描述过程，有可能使程序更清晰

在 OO 语言里提供类似函数式语言 lambda 表达式的功能，主要是提供匿名函数，简化程序书写；也想支持一些高级编程技术

## 第二章 构造数据抽象
### 2.1 抽象屏障
建立层次性抽象屏障的价值：
-  数据表示和使用隔离，两部分可以独立演化，容易维护和修改
- 实现好的数据抽象可以用于其他程序和系统，可能做成库
- 一些设计决策可以推迟，直到有了更多实际信息后再处理


