# Java虚拟机(Java内存区域)_1


# 1 Java内存区域

## 1.1 内存区域

![Alt text](https://raw.githubusercontent.com/zhangtao6483/note/master/img/jvm/JvmSpec7.png)

### 1.1.1 程序计数器（Program Counter Register）

- 字节码的行号指示器
- 字节码解释器工作时通过改变计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都依赖。
- 每个线程拥有一个PC寄存器
- 在线程创建时创建
- 指向下一条指令的地址
- 当线程在执行的是Native方法（调用本地操作系统方法）时，该计数器的值为undefined
- 没有规定任何OOM情况的区域。

### 1.1.2 方法区（Method Area）

- 保存装载的类信息
  
  - 类型的常量池
  - 字段、方法信息
  - 方法字节码
   
- 全局共享
- 可能出现OutOfMemoryError异常
- JDK6：String等常量信息置于方法区，JDK7，移动到了堆
- HotSpot虚拟机将GC分代收集扩展至方法区，或者说使用永久代来实现方法区
- JDK8 HotSpot JVM开始使用本地化的内存存放类的元数据，这个空间叫做元空间（Metaspace）

### 1.1.3 Java堆（Java Heap）

- 所有线程共享Java堆
- 应用系统对象都保存在Java堆中
- JVMS明确要求该区域需要实现自动内存管理
- 可能出现OutOfMemoryError

### 1.1.4 Java栈

- 线程私有
- 栈由一系列帧组成（java栈也叫作帧栈）
- 帧保存一个方法的局部变量、操作数栈、常量池指针
- 每一次方法调用创建一个帧，并压栈
- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

#### 1.1.4.1 栈帧

- Java虚拟机栈中存储的内容，它被用于存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、方法返回值和异常分派
- 一个完整的栈帧包含：局部变量表、操作数栈、动态连接信息、方法正常完成和异常完成信息

#### 1.1.4.2 局部变量表

- 由若干个Slot组成，长度由编译器决定
- 单个Slot可以存储一个类型为boolean、byte、char、short、float、reference和returnAddress的数据，两个Slot可以存储一个类型为long或double的数据
- 局部变量表用于方法间参数传递，以及方法执行过程中存储基础数据类型的值和对象的引用


#### 1.1.4.3 操作数栈

- 是一个后进先出栈，由若干个Entry组成，长度由编译期决定
- 单个Entry既可以存储一个Java虚拟机中定义的任意数据类型的值，包括long和double，但是存储long和double类型的Entry深度为2，其他类型的深度为1
- 在方法执行过程中，栈帧用于存储计算参数和计算结果；在方法调用时，操作数栈也用来准备调用方法的参数以及接受方法返回结果

![Alt text](https://raw.githubusercontent.com/zhangtao6483/note/master/img/jvm/4.png)

### 1.1.5 直接内存（Direct Memory）

直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受Java堆大小的限制，但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致OutOfMemoryError异常出现。


## 1.2 内存溢出

下面给出个内存区域内存溢出的简单测试方法:

| 内存区域              |    内存溢出的测试方法                                  |
| :-----------------:  | :---------------------------------------------------:|
| java堆               |无限循环的new出对象来（在List中保存引用，以保证不被垃圾回收） |
| 方法区                |   生成大量动态类（非常量池）						      |
| 虚拟机栈和本地方法栈    |   递归、无限循环创建线程							      |

# 2 内存模型

- 每一个线程有一个工作内存和主存独立
- 工作内存存放主存中变量的值得拷贝

![Alt text](https://raw.githubusercontent.com/zhangtao6483/note/master/img/jvm/5.png)

- 当数据从内存复制到工作存储时，必须出现两个操作：
  
  1. 由主内存执行read操作
  2. 由工作内存执行相应的load操作

- 当数据从工作内存拷贝到主存时，也是两个操作

  1. 由工作内存执行的store操作
  2. 由主内存执行相应的write操作

- 每一个操作都是原子的
- 对应普通变量，一个线程中更新的值，不能马上反应在其他变量中。如果需要在其他线程中立即可见，需要使用volatile






参考资料：
http://www.importnew.com/19946.html
