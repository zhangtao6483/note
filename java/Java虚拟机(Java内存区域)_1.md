# Java虚拟机(Java内存区域)_1


# 1 Java内存区域与内存溢出

## 1.1 内存区域

![Alt text](https://raw.githubusercontent.com/zhangtao6483/note/master/img/jvm/JvmSpec7.png)

### 1.1.1 程序计数器（Program Counter Register）

字节码的行号指示器<br>
字节码解释器工作时通过改变计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都依赖。<br>
当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法（调用本地操作系统方法）时，该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中么有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。

### 1.1.2 Java虚拟机栈（Java Virtual Machine Stacks）

*虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于**支持续虚拟机进行方法调用和方法执行的数据结构**。*
<br>
活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。<br>
栈帧用于*存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。*

一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。<br>
在Java虚拟机规范中，对这个区域规定了两种异常情况：

 1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
 2. 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

这两种情况存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。而在多线程环境下，则会抛出OutOfMemoryError异常。

#### 1.1.2.1 栈帧

- Java虚拟机栈中存储的内容，它被用于存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、方法返回值和异常分派
- 一个完整的栈帧包含：局部变量表、操作数栈、动态连接信息、方法正常完成和异常完成信息

#### 1.1.2.1 局部变量表

- 由若干个Slot组成，长度由编译器决定
- 单个Slot可以存储一个类型为boolean、byte、char、short、float、reference和returnAddress的数据，两个Slot可以存储一个类型为long或double的数据
- 局部变量表用于方法间参数传递，以及方法执行过程中存储基础数据类型的值和对象的引用


#### 1.1.2.2 操作数栈

- 是一个后进先出栈，由若干个Entry组成，长度由编译期决定
- 单个Entry既可以存储一个Java虚拟机中定义的任意数据类型的值，包括long和double，但是存储long和double类型的Entry深度为2，其他类型的深度为1
- 在方法执行过程中，栈帧用于存储计算参数和计算结果；在方法调用时，操作数栈也用来准备调用方法的参数以及接受方法返回结果


![Alt text](https://raw.githubusercontent.com/zhangtao6483/note/master/img/jvm/4.png)

### 1.1.3 本地方法栈（Native Method Stacks）

该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。<br>
Hotspot虚拟机直接把本地方法栈和虚拟机栈合二为一

---

### 1.1.4 Java堆（Java Heap）

- 全局共享
- 通常是Java虚拟机中最大的一块内存区域
- 作用是做为Java对象的主要存储区域
- JVMS明确要求该区域需要实现自动内存管理
- 可能出现OutOfMemoryError


### 1.1.5 方法区（Method Area）

- 全局共享
- 作用是存储Java类的结构信息
- JVMS不要求对该区域实现自动内存管理，但是商用Java虚拟机都能够自动管理
- 可能出现OutOfMemoryError异常

它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>
或者叫“永久代（Permanent Generation）”，HotSpot虚拟机将GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，但使用永久带来实现方法区，更容易造成内存溢出问题<br>
JDK 8.HotSpot JVM开始使用本地化的内存存放类的元数据，这个空间叫做元空间（Metaspace）。<br>
意味着java.lang.OutOfMemoryError: PermGen的空间问题将不复存在，并且不再需要调整和监控这个内存空间，如果设置了MaxMetaspaceSize的大小，会抛出java.lang.OutOfMemoryError: Metadata space的异常

永久区的情况：

 - 这个内存空间被完全的移除 
 - JVM参数PermSize 和 MaxPermSize会被忽略，当前在启动时会有警告信息 

 
元空间（Metaspace）内存分配模型

 - 现在大多数的类元数据分配在本地化内存中。
 - 我们用来描述类的元数据的klasses已经被移除。 

元空间的容量

 - 默认情况下，类元数据分配受到可用的本机内存容量的限制（容量依然取决于你使用32位JVM还是64位操作系统的虚拟内存的可用性）。 
 - 一个新的参数 (MaxMetaspaceSize)可以使用。允许你来限制用于类元数据的本地内存。如果没有特别指定，元空间将会根据应用程序在运行时的需求动态设置大小。 

元空间的垃圾回收<br>

 - 如果类元数据的空间占用达到参数“MaxMetaspaceSize”设置的值，将会触发对死亡对象和类加载器的垃圾回收。 
 - 为了限制垃圾回收的频率和延迟，适当的监控和调优元空间是非常有必要的。元空间过多的垃圾收集可能表示类，类加载器内存泄漏或对你的应用程序来说空间太小了。

JDK7

 - 符号表被移到Native Heap中
 - 字符串常量和类的静态引用被移到Java Heap中

JDK8<br>
永久代已被元空间（Metaspace）所代替

  
#### 1.1.5.1 运行时常量池（Runtime Constant Pool）

- 方法区的一部分
- 全局共享
- 作用是存储Java类文件常量池中的符号信息
- 可能出现OutOfMemoryError异常

### 1.1.6 直接内存（Direct Memory）

直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受Java堆大小的限制，但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致OutOfMemoryError异常出现。


## 1.2 内存溢出

下面给出个内存区域内存溢出的简单测试方法:

| 内存区域              |    内存溢出的测试方法                                  |
| :-----------------:  | :---------------------------------------------------:|
| java堆               |无限循环的new出对象来（在List中保存引用，以保证不被垃圾回收） |
| 方法区                |   生成大量动态类（非常量池）						      |
| 虚拟机栈和本地方法栈    |   递归、无限循环创建线程							      |


Minor GC触发条件：当Eden区满时，触发Minor GC。

Full GC触发条件：

1. 调用System.gc时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

参考资料：
http://www.importnew.com/19946.html
