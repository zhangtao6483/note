# GC

## 1 GC算法

### 1.1 引用计数法

- 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。
- 引用计数法的问题
  
  - 引用和去引用伴随加法和减法，影响性能
  - 很难处理循环引用

### 1.2 标记-清除算法

- 标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。
- 在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。
- 在清除阶段，清除所有未被标记的对象。
- 缺点： 标记清除后产生大量不连续的内存碎片

### 1.3 标记-压缩算法

- 并不是简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。
- 适合用于存活对象较多的场合，如老年代
- 缺点：标记和整理阶段必须停止执行线程

### 1.4 复制算法

- 与标记-清除算法相比，复制算法是一种相对高效的回收方法
- 不适用于存活对象较多的场合
- 将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收
- 缺点： 将内存缩小为原来的一半

### 1.5 分代思想

- 依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。
- 根据不同代的特点，选取合适的收集算法
  
  - 少量对象存活，适合复制算法
  - 大量对象存活，适合标记清理或者标记压缩

## 2 可触及性

- 可触及的

  - 从根节点可以触及到这个对象

- 可复活的

  - 一旦所有引用被释放，就是可复活状态
  - 因为在finalize()中可能复活该对象

- 不可触及的

  - 在finalize()后，可能会进入不可触及状态
  - 不可触及的对象不可能复活
  - 可以回收


### 2.1 GC Roots

- 在虚拟机栈（栈帧中的本地变量表）中的引用的对象
- 在方法区中的类静态属性引用的对象
- 在方法区中的常量引用的对象
- 在本地方法栈中JNI（Native方法）的引用的对象

## 3 Stop-The_World

- Java中一种全局暂停的现象
- 全局停顿，所有Java代码停止，native代码可以执行，但不能和JVM交互
- 多半由于GC引起

  - Dump线程
  - 死锁检查
  - 堆Dump

- 危害
  
  - 长时间服务停止，没有响应
  - 遇到HA系统，可能引起主备切换，严重危害生产环境

## 4 GC

Minor GC触发条件：当Eden区满时，触发Minor GC。

Full GC触发条件：

1. 调用System.gc时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小