# 1 AbstractQueuedSynchronizer

## 1.1 介绍

- AQS本身是没有实现任何同步接口的，它仅仅只是定义了同步状态的获取和释放的方法来供自定义的同步组件的使用
- AQS定义两种资源共享方式：Exclusive（独占锁）和Share（共享锁）。
- 内部使用一个int变量表示同步状态，通过FIFO队列维护等待获取资源线程，同时保持等待队列的头节点head和尾节点head。

AQS构成：

1. Node 节点：用于存放获取线程的节点, 存在于 Sync Queue, Condition Queue, 这些节点主要的区分在于 waitStatus 的值
2. Condition Queue：这个队列是用于独占模式中，唤起指定线程
3. Sync Queue, 独占 共享的模式中均会使用到的存放 Node 的 CLH queue
4. ConditionObject, 用于独占的模式, 主要是线程释放lock, 加入 Condition Queue, 并进行相应的 signal 操作。
5. 独占的获取lock (acquire, release), eg： ReentrantLock。
6. 共享的获取lock (acquireShared, releaseShared), eg： ReeantrantReadWriteLock, Semaphore, CountDownLatch


## 1.2 Node

- 依赖于一个CLH队列来管理锁，CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。
- CLH锁可以更容易地去实现“取消 （cancellation）”和“超时”功能
- "prev" 连接（原始CLH锁没有使用）主要是出于处理取消的需求。如果一个结点被取消，它的后继（一般）是重新连接到一个非取消的前驱。

- waitStatus维护线程状态：

 状态| 值 | 描述
------------- | -------------|---------|
CANCELLED	| 1 | 取消状态 |
SIGNAL | -1 | 等待触发状态 |
CONDITION	| -2 | 等待条件状态 |
PROPAGATE	| -3 | 状态需要向后传播|

- 等待队列是FIFO先入先出，只有前一个节点的状态为SIGNAL时，当前节点的线程才能被挂起。

## 1.3 方法

 方法名称	| 描述 |
------------- | -------------|
boolean tryAcquire(int arg)	| 尝试获取独占锁|
boolean tryRelease(int arg) 	| 尝试释放独占锁|
int tryAcquireShared(int arg)	| 尝试获取共享锁|
boolean tryReleaseShared(int arg)	| 尝试释放共享锁|
boolean isHeldExclusively()	| 当前线程是否获得了独占锁|

https://coderbee.net/index.php/concurrent/20131205/600<br>
http://gee.cs.oswego.edu/dl/papers/aqs.pdf<br>

