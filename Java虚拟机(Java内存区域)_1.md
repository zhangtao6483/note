# Java虚拟机(Java内存区域)_1

[toc]

---
@(Java)[Java]

#1 Java内存区域与内存溢出
##1.1 内存区域
![enter image description here](https://en.wikipedia.org/wiki/File:JvmSpec7.png)

###1.1.1 程序计数器（Program Counter Register）
字节码的行号指示器
字节码解释器工作时通过改变计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都依赖。
当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法（调用本地操作系统方法）时，该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中么有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。

###1.1.2 Java虚拟机栈（Java Virtual Machine Stacks）
*虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于**支持续虚拟机进行方法调用和方法执行的数据结构**。*
活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。
栈帧用于*存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。*

一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。
在Java虚拟机规范中，对这个区域规定了两种异常情况：
	1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
	2. 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

这两种情况存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。而在多线程环境下，则会抛出OutOfMemoryError异常。

####1.1.2.1 局部变量表
局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是*编译期可知的各种基本数据类型*（boolean、byte、char、short、int、float、long、double）、对象引用（reference）和returnAddress类型（它指向了一条字节码指令的地址）

####1.1.2.2 操作数栈
当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。
> Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。因此我们也称Java虚拟机是基于栈的，这点不同于Android虚拟机，Android虚拟机是基于寄存器的。
> 基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些；而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差。

####1.1.2.3 动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。

####1.1.2.4 方法返回地址
当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。

###1.1.3 本地方法栈（Native Method Stacks）
该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。
Hotspot虚拟机直接把本地方法栈和虚拟机栈合二为一

---
###1.1.4 Java堆（Java Heap）
Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存
如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。

###1.1.5 方法区（Method Area）
它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
或者叫“永久代（Permanent Generation）”，HotSpot虚拟机将GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，但使用永久带来实现方法区，更容易造成内存溢出问题
JDK 8.HotSpot JVM开始使用本地化的内存存放类的元数据，这个空间叫做元空间（Metaspace）。
意味着java.lang.OutOfMemoryError: PermGen的空间问题将不复存在，并且不再需要调整和监控这个内存空间，如果设置了MaxMetaspaceSize的大小，会抛出java.lang.OutOfMemoryError: Metadata space的异常

> 永久区的情况：
>	- 这个内存空间被完全的移除 
>  - JVM参数PermSize 和 MaxPermSize会被忽略，当前在启动时会有警告信息 
>  
> 元空间（Metaspace）内存分配模型
>  - 现在大多数的类元数据分配在本地化内存中。
>  - 我们用来描述类的元数据的klasses已经被移除。 
>
> 元空间的容量
>  - 默认情况下，类元数据分配受到可用的本机内存容量的限制（容量依然取决于你使用32位JVM还是64位操作系统的虚拟内存的可用性）。 
>  - 一个新的参数 (MaxMetaspaceSize)可以使用。允许你来限制用于类元数据的本地内存。如果没有特别指定，元空间将会根据应用程序在运行时的需求动态设置大小。 
>
> 元空间的垃圾回收
>  - 如果类元数据的空间占用达到参数“MaxMetaspaceSize”设置的值，将会触发对死亡对象和类加载器的垃圾回收。 
>  - 为了限制垃圾回收的频率和延迟，适当的监控和调优元空间是非常有必要的。元空间过多的垃圾收集可能表示类，类加载器内存泄漏或对你的应用程序来说空间太小了。

####1.1.5.1 运行时常量池（Runtime Constant Pool）
方法区的一部分，存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放

###1.1.6 直接内存（Direct Memory）
直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受Java堆大小的限制，但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致OutOfMemoryError异常出现。

---
##1.2 内存溢出

下面给出个内存区域内存溢出的简单测试方法:

| 内存区域              |    内存溢出的测试方法                                  |
| :-----------------:  | :---------------------------------------------------:|
| java堆               |无限循环的new出对象来（在List中保存引用，以保证不被垃圾回收） |
| 方法区                |   生成大量动态类（非常量池）						      |
| 虚拟机栈和本地方法栈    |   递归、无限循环创建线程							      |



参考资料：
http://www.importnew.com/19946.html
